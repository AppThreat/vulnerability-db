from semver import VersionInfo

try:
    import orjson

    ORJSON_AVAILABLE = True
except ImportError:
    import json

    ORJSON_AVAILABLE = False
import uuid
from vdb.lib import (
    CPE_REGEX,
    KNOWN_PKG_TYPES,
    Vulnerability,
    VulnerabilityDetail,
    VulnerabilitySource,
)
from vdb.lib.cve_model import (
    CVE,
    OrgId,
    CVE1,
    Affected,
    Containers,
    CnaPublishedContainer,
    Cpe,
    CveId,
    CveMetadataPublished,
    DataType,
    DataVersion,
    Description,
    Description1,
    Language,
    Metrics,
    Metrics1,
    ProblemType,
    ProblemTypes,
    Product,
    ProviderMetadata,
    Reference,
    References,
    State,
    Status,
    UuidType,
    Version,
    Versions,
)
from vdb.lib.cve_model.cvss_v3 import Field1

json_lib = orjson if ORJSON_AVAILABLE else json


ASSIGNER_UUID_MAP = {}


def to_cve_metadata(avuln: Vulnerability):
    # Re-use the assigner org id
    if avuln.assigner:
        if ASSIGNER_UUID_MAP.get(avuln.assigner):
            assigner_org_id = ASSIGNER_UUID_MAP[avuln.assigner]
        else:
            assigner_org_id = OrgId(UuidType(str(uuid.uuid4())))
            ASSIGNER_UUID_MAP[avuln.assigner] = assigner_org_id
    else:
        assigner_org_id = OrgId(UuidType(str(uuid.uuid4())))
    metadata = CveMetadataPublished(
        cveId=CveId(avuln.id),
        state=State.PUBLISHED,
        assignerOrgId=assigner_org_id,
    )
    metadata.datePublished = avuln.source_orig_time
    metadata.dateUpdated = avuln.source_update_time
    return metadata


def all_semver_compatible(adetail: VulnerabilityDetail) -> bool:
    if adetail.mii and adetail.mii != "*" and not VersionInfo.is_valid(adetail.mii):
        return False
    if adetail.mae and adetail.mae != "*" and not VersionInfo.is_valid(adetail.mae):
        return False
    if adetail.mie and adetail.mie != "*" and not VersionInfo.is_valid(adetail.mie):
        return False
    if adetail.mai and adetail.mai != "*" and not VersionInfo.is_valid(adetail.mai):
        return False
    return True


def to_product_versions(vendor, adetail: VulnerabilityDetail) -> list[Versions]:
    versions = []
    lt_captured = False
    # Try to detect the version_type
    version_type = "custom"
    if vendor in KNOWN_PKG_TYPES:
        version_type = vendor
    elif all_semver_compatible(adetail):
        version_type = "semver"
    # The goal is to create a single entry with either version and lessThan
    #   or version and lessThanOrEqual
    # If this is not possible then we create a separate version objects
    if adetail.mii and adetail.mii not in ("*", "-"):
        if adetail.mai and adetail.mai not in ("*", "-"):
            versions.append(
                Versions(
                    version=Version(adetail.mii),
                    lessThanOrEqual=Version(adetail.mai),
                    versionType=version_type,
                    status=Status.affected,
                )
            )
            lt_captured = True
        elif adetail.mae and adetail.mae not in ("*", "-"):
            versions.append(
                Versions(
                    version=Version(adetail.mii),
                    lessThan=Version(adetail.mai),
                    versionType=version_type,
                    status=Status.affected,
                )
            )
            lt_captured = True
        else:
            versions.append(
                Versions(
                    version=Version(adetail.mii),
                    versionType=version_type,
                    status=Status.affected,
                )
            )
    if adetail.mie and adetail.mie not in ("*", "-"):
        versions.append(
            Versions(
                version=Version(adetail.mie),
                versionType=version_type,
                status=Status.unaffected,
            )
        )
    if not lt_captured:
        if adetail.mai and adetail.mai not in ("*", "-"):
            versions.append(
                Versions(
                    version=Version(adetail.mai),
                    lessThanOrEqual=Version(adetail.mai),
                    versionType=version_type,
                    status=Status.affected,
                )
            )
        if adetail.mae and adetail.mae not in ("*", "-"):
            versions.append(
                Versions(
                    version=Version(adetail.mae),
                    lessThan=Version(adetail.mae),
                    versionType=version_type,
                    status=Status.affected,
                )
            )
    return versions


def to_cve_affected(avuln: Vulnerability) -> Affected | None:
    products = []
    adetail: VulnerabilityDetail
    for adetail in avuln.details:
        cpe_uri = adetail.cpe_uri
        parts = CPE_REGEX.match(cpe_uri)
        versions = to_product_versions(parts.group("vendor"), adetail)
        if parts and versions:
            p = Product(
                vendor=parts.group("vendor"),
                product=parts.group("package"),
                packageName=parts.group("package"),
                cpes=[Cpe(cpe_uri)],
                defaultStatus=Status.unknown,
                versions=versions,
            )
            products.append(p)
    return Affected(products) if products else None


def to_cve_containers(avuln: Vulnerability) -> CnaPublishedContainer | None:
    provier_meta = ProviderMetadata(
        orgId=ASSIGNER_UUID_MAP.get(avuln.assigner, OrgId(UuidType(str(uuid.uuid4()))))
    )
    provier_meta.dateUpdated = avuln.source_update_time
    affected = to_cve_affected(avuln)
    if not affected:
        return None
    cont = CnaPublishedContainer(
        providerMetadata=provier_meta,
        descriptions=[Description(lang=Language("en"), value=avuln.description)],
        affected=affected,
        metrics=Metrics(
            [
                Metrics1(
                    cvssV3_1=Field1(
                        version="3.1",
                        baseScore=avuln.cvss_v3.base_score,
                        baseSeverity=avuln.severity,
                        vectorString=avuln.cvss_v3.vector_string,
                        attackVector=avuln.cvss_v3.attack_vector,
                        attackComplexity=avuln.cvss_v3.attack_complexity,
                        privilegesRequired=avuln.cvss_v3.privileges_required,
                        userInteraction=avuln.cvss_v3.user_interaction,
                        scope=avuln.cvss_v3.scope,
                        confidentialityImpact=avuln.cvss_v3.confidentiality_impact,
                        integrityImpact=avuln.cvss_v3.integrity_impact,
                        availabilityImpact=avuln.cvss_v3.availability_impact,
                    )
                )
            ]
        ),
        references=References([Reference(url=url) for url in avuln.related_urls]),
    )
    cont.dateAssigned = avuln.source_orig_time
    # CWE
    if avuln.problem_type and "noinfo" not in avuln.problem_type:
        cont.problemTypes = ProblemTypes(
            [
                ProblemType(
                    descriptions=[
                        Description1(
                            lang=Language("en"),
                            description=avuln.problem_type,
                            cweId=avuln.problem_type,
                            type="CWE",
                        )
                    ]
                )
            ]
        )
    return cont


class CVESource(VulnerabilitySource):
    """
    Generic CVE source that uses the CVE 5.0 models
    """

    db = None

    @classmethod
    def download_all(cls, local_store=True):
        pass

    @classmethod
    def download_recent(cls, local_store=True):
        pass

    @classmethod
    def bulk_search(cls, app_info, pkg_list):
        pass

    @classmethod
    def refresh(cls):
        pass

    def convert(self, data: list[Vulnerability]) -> list[CVE1]:
        cves = []
        for avuln in data:
            containers = Containers(cna=to_cve_containers(avuln))
            if containers:
                cve_obj = CVE1(
                    dataType=DataType.CVE_RECORD,
                    dataVersion=DataVersion.field_5_0,
                    cveMetadata=to_cve_metadata(avuln),
                    containers=containers,
                )
                cves.append(cve_obj)
        return cves

    def store(self, data: list[CVE1]):
        pass
